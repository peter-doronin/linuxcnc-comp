/* Autogenerated by /usr/bin/halcompile on Wed Dec 23 17:03:41 2020 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"
#include <stdio.h>

#include "servo.h"


#undef fperiod
#define fperiod (period * 1e-9)

#define MAX_CHAN 8

/* module information */
MODULE_AUTHOR("Peter Doronin");
MODULE_DESCRIPTION("Servo control");
MODULE_LICENSE("GPL");

static int comp_id;
static int num_chan = 1;        /* number of channels - default = 1 */
RTAPI_MP_INT(num_chan, "number of channels");


typedef struct comp_data_t
{
    struct comp_data_t *next;
    hal_bit_t *enable_in;
    hal_bit_t *estop_in;
    hal_bit_t *fault;
    hal_u32_t *status_out;
    hal_s32_t *debug;
} comp_data_t;


comp_data_t *data_first_inst = 0, *data_last_inst = 0;


static void update(void *arg, long period);
static void traj_cmd(void *arg, long period);
static void traj_fb(void *arg, long period);
static int export_common(comp_data_t * data);
static int export_servo(int num, comp_data_t * data);
static int setup_servo(int num, servo_data_t * data);
static int setup_common(comp_data_t * data);

static int setup_servo(int num, servo_data_t * data)
{
    data->TRAJ.pos_scale = 1280000;
    //*data->TRAJ.offset = 2;
}

static int setup_common(comp_data_t * data)
{
    servo_data_t *sd = (servo_data_t *)(&data_first_inst + 1);
}

int rtapi_app_main(void)
{
    int n, retval;
    rtapi_set_msg_level(3);
    rtapi_print_msg(RTAPI_MSG_INFO, "SERVO: component start\n");

    /* test for number of channels */
    if ((num_chan <= 0) || (num_chan > MAX_CHAN)) {
            rtapi_print_msg(RTAPI_MSG_ERR, "SERVO: ERROR: invalid num_chan: %d\n", num_chan);
            return -EINVAL;
        }
    /* have good config info, connect to the HAL */
    comp_id = hal_init("servo");
    if (comp_id < 0) {
            rtapi_print_msg(RTAPI_MSG_ERR, "SERVO: ERROR: hal_init() failed\n");
            return -EINVAL;
        }
    /* allocate shared memory for counter data */
    comp_data_t *comp_data;
    comp_data = (comp_data_t *)hal_malloc(sizeof(comp_data_t) + (num_chan * sizeof(servo_data_t)));
    if (!comp_data) {
            rtapi_print_msg(RTAPI_MSG_ERR, "SERVO: ERROR: hal_malloc() failed\n");
            hal_exit(comp_id);
            return -ENOMEM;
        }

    /* export all the variables for each counter */
    for (n = 0; n < num_chan; n++) {
            /* export all vars */
            retval = export_servo(n, comp_data);
            if (retval != 0) {
                    rtapi_print_msg(RTAPI_MSG_ERR, "SERVO: ERROR: counter %d var export failed\n", n);
                    hal_exit(comp_id);
                    return -EIO;
                }
        }
    retval = export_common(comp_data);
    if (retval != 0) {
            rtapi_print_msg(RTAPI_MSG_ERR, "SERVO: ERROR: counter %d var export failed\n", n);
            hal_exit(comp_id);
            return -EIO;
        }
    /* export functions */
    retval = hal_export_funct("servo.update", update, comp_data, 0, 0, comp_id);
    if (retval != 0) {
            rtapi_print_msg(RTAPI_MSG_ERR, "SERVO: ERROR: count funct export failed\n");
            hal_exit(comp_id);
            return -EIO;
        };
        
    retval = hal_export_funct("servo.traj_cmd", traj_cmd, comp_data, 0, 0, comp_id);
    if (retval != 0) {
            rtapi_print_msg(RTAPI_MSG_ERR, "SERVO: ERROR: count funct export failed\n");
            hal_exit(comp_id);
            return -EIO;
        };
        
    retval = hal_export_funct("servo.traj_fb", traj_fb, comp_data, 0, 0, comp_id);
    if (retval != 0) {
            rtapi_print_msg(RTAPI_MSG_ERR, "SERVO: ERROR: count funct export failed\n");
            hal_exit(comp_id);
            return -EIO;
        };
        
    if(data_last_inst) data_last_inst->next = comp_data;
    data_last_inst = comp_data;
    if(data_first_inst) data_first_inst = comp_data;
    hal_ready(comp_id);
    return 0;
}

static void traj_cmd(void *arg, long period)
{ 
    comp_data_t *data = (comp_data_t *)arg;
    servo_data_t *sd = (servo_data_t *)(data + 1);

    for (int n = 0; n < num_chan; n++)
        {
           calc_command(sd, n);
        };
}

static void traj_fb(void *arg, long period)
{ 
    comp_data_t *data = (comp_data_t *)arg;
    servo_data_t *sd = (servo_data_t *)(data + 1);

    for (int n = 0; n < num_chan; n++)
        {
           calc_feedback(sd, n);
        };
}

static void update(void *arg, long period)
{
    comp_data_t *data = (comp_data_t *)arg;
    servo_data_t *sd = (servo_data_t *)(data + 1);

    static int timer;
    if(timer > 2){
        timer = 0;
        *data->status_out = 0;
        *data->fault = 0;
        for (int n = 0; n < num_chan; n++)
           {
                state_mach(sd, n);
                if(sd[n].IO.state < 2) {*data->fault = 1;};
            };} else {timer++;};


    static long time1;
    *data->debug = (int32_t)(rtapi_get_time() - time1 - 1000000L);
    time1 =  rtapi_get_time();
};

static int export_servo(int num, comp_data_t * comp)
{
    comp_data_t *cd = comp;
    servo_data_t *sd = ((servo_data_t *)(comp + 1)) + num;
    int r;
    if(r != 0) return r;
    r = hal_pin_u32_newf(HAL_OUT, &(sd->IO.out6040), comp_id, "servo.%d.out6040", num);
    if(r != 0) return r;
    r = hal_pin_u32_newf(HAL_IN, &(sd->IO.in6041), comp_id, "servo.%d.in6041", num);
    if(r != 0) return r;
    r = hal_pin_u32_newf(HAL_OUT, &(sd->IO.out6060), comp_id, "servo.%d.out6060", num);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(sd->TRAJ.out60c1_1), comp_id, "servo.%d.out60c1-1", num);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(sd->TRAJ.out60c1_2), comp_id, "servo.%d.out60c1-2", num);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_IN, &(sd->TRAJ.in6064), comp_id, "servo.%d.in6064", num);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(sd->TRAJ.pos_cmd), comp_id, "servo.%d.pos-cmd", num);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(sd->TRAJ.pos_fb), comp_id, "servo.%d.pos-fb", num);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(sd->IO.online), comp_id, "servo.%d.online", num);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(sd->IO.vel_mode), comp_id, "servo.%d.vel-mode", num);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &sd->TRAJ.pos_scale, comp_id, "servo.%d.pos-scale", num); //param!!!
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(sd->TRAJ.offset), comp_id, "servo.%d.pos-offset", num);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(sd->TRAJ.debug), comp_id, "servo.%d.debug", num);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(sd->IO.home_req), comp_id, "servo.%d.home-req", num);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(sd->IO.homed_out), comp_id, "servo.%d.homed", num);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(sd->IO.homing_out), comp_id, "servo.%d.homing", num);
    if(r != 0) return r;
    r = hal_pin_s32_newf(HAL_OUT, &(sd->IO.state_out), comp_id, "servo.%d.state", num);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(sd->IO.home_err), comp_id, "servo.%d.home-err", num);
    if(r != 0) return r;

    sd->IO.estop_in = &comp->estop_in;
    sd->IO.enable_in = &comp->enable_in;

    setup_servo(num, sd);
    rtapi_print_msg(RTAPI_MSG_INFO, "SERVO: instance [%d] created\n", num);
    return 0;
}


static int export_common(comp_data_t * data)
{
    int r;
    r = hal_pin_bit_new("servo.enable-in", HAL_IN, &(data->enable_in), comp_id);
    if(r != 0) return r;
    r = hal_pin_bit_new("servo.estop-in", HAL_IN, &(data->estop_in), comp_id);
    if(r != 0) return r;
    r = hal_pin_u32_new("servo.status-out", HAL_OUT, &(data->status_out), comp_id);
    if(r != 0) return r;
    r = hal_pin_s32_new("servo.debug", HAL_OUT, &(data->debug), comp_id);
    if(r != 0) return r;
    r = hal_pin_bit_new("servo.fault", HAL_OUT, &(data->fault), comp_id);
    if(r != 0) return r;
    rtapi_print_msg(RTAPI_MSG_INFO, "SERVO: common instance created\n");
    return 0;
}

void rtapi_app_exit(void)
{
    if(data_last_inst->next)
        {
            servo_data_t *sd = (servo_data_t *)(&data_last_inst + 1);
            for (int n = 0; n < num_chan; n++)
                {
                    sd[n].IO.out6040 = 0;
                };
        };
    rtapi_print_msg(RTAPI_MSG_INFO, "SERVO: component exit\n");
    hal_exit(comp_id);
}
